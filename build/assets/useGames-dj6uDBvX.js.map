{"version":3,"file":"useGames-dj6uDBvX.js","sources":["../../src/hooks/useGames.ts"],"sourcesContent":["import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { SupabaseService } from '../lib/supabaseService';\nimport { useAppStore } from '../store/appStore';\nimport { toast } from 'sonner';\n\n// Query keys\nexport const gameKeys = {\n  all: ['games'] as const,\n  lists: () => [...gameKeys.all, 'list'] as const,\n  list: (filters: Record<string, any>) => [...gameKeys.lists(), { filters }] as const,\n  details: () => [...gameKeys.all, 'detail'] as const,\n  detail: (id: string) => [...gameKeys.details(), id] as const,\n  participants: (id: string) => [...gameKeys.detail(id), 'participants'] as const,\n};\n\n// Hook for fetching games\nexport function useGames() {\n  const { user } = useAppStore();\n  \n  return useQuery({\n    queryKey: gameKeys.lists(),\n    queryFn: async () => {\n      console.log('üîç Fetching games with React Query');\n      const games = await SupabaseService.getGames();\n      console.log('‚úÖ Games fetched:', games.length);\n      return games;\n    },\n    staleTime: 2 * 60 * 1000, // 2 minutes\n    gcTime: 5 * 60 * 1000, // 5 minutes (was cacheTime in v4)\n    // Remove authentication requirement - games should load for all users\n    // enabled: !!user, // Only fetch when user is authenticated\n  });\n}\n\n// Hook for fetching a single game\nexport function useGame(gameId: string) {\n  return useQuery({\n    queryKey: gameKeys.detail(gameId),\n    queryFn: async () => {\n      return await SupabaseService.getGameById(gameId);\n    },\n    enabled: !!gameId,\n  });\n}\n\n// Hook for fetching game participants\nexport function useGameParticipants(gameId: string) {\n  return useQuery({\n    queryKey: gameKeys.participants(gameId),\n    queryFn: () => SupabaseService.getGameParticipants(gameId),\n    enabled: !!gameId,\n    staleTime: 1 * 60 * 1000, // 1 minute\n  });\n}\n\n// Hook for joining a game\nexport function useJoinGame() {\n  const queryClient = useQueryClient();\n  const { user } = useAppStore();\n\n  return useMutation({\n    mutationFn: async (gameId: string) => {\n      console.log('üîß Joining game:', gameId);\n      await SupabaseService.joinGame(gameId);\n    },\n    onMutate: async (gameId) => {\n      // Cancel outgoing refetches for all related queries\n      await queryClient.cancelQueries({ queryKey: gameKeys.lists() });\n      await queryClient.cancelQueries({ queryKey: gameKeys.detail(gameId) });\n      await queryClient.cancelQueries({ queryKey: gameKeys.participants(gameId) });\n      \n      // Snapshot previous values\n      const previousGames = queryClient.getQueryData(gameKeys.lists());\n      const previousGame = queryClient.getQueryData(gameKeys.detail(gameId));\n      const previousParticipants = queryClient.getQueryData(gameKeys.participants(gameId));\n      \n      // Optimistically update games list\n      queryClient.setQueryData(gameKeys.lists(), (old: any) => {\n        if (!old) return old;\n        return old.map((game: any) => \n          game.id === gameId \n            ? { \n                ...game, \n                isJoined: true, \n                currentPlayers: Math.min(game.currentPlayers + 1, game.maxPlayers)\n              }\n            : game\n        );\n      });\n\n      // Optimistically update game detail\n      queryClient.setQueryData(gameKeys.detail(gameId), (old: any) => {\n        if (!old) return old;\n        return {\n          ...old,\n          isJoined: true,\n          currentPlayers: Math.min(old.currentPlayers + 1, old.maxPlayers)\n        };\n      });\n\n      // Optimistically update participants list\n      if (user) {\n        queryClient.setQueryData(gameKeys.participants(gameId), (old: any) => {\n          if (!old) return [{ id: user.id, name: user.name, avatar: user.avatar }];\n          const isAlreadyJoined = old.some((p: any) => p.id === user.id);\n          if (isAlreadyJoined) return old;\n          return [...old, { id: user.id, name: user.name, avatar: user.avatar }];\n        });\n      }\n      \n      return { previousGames, previousGame, previousParticipants };\n    },\n    onError: (error, gameId, context) => {\n      console.error('‚ùå Join game error:', error);\n      \n      // Rollback on error\n      if (context?.previousGames) {\n        queryClient.setQueryData(gameKeys.lists(), context.previousGames);\n      }\n      if (context?.previousGame) {\n        queryClient.setQueryData(gameKeys.detail(gameId), context.previousGame);\n      }\n      if (context?.previousParticipants) {\n        queryClient.setQueryData(gameKeys.participants(gameId), context.previousParticipants);\n      }\n      \n      toast.error('Failed to join game', {\n        description: 'Please try again later',\n      });\n    },\n    onSuccess: (_, gameId) => {\n      console.log('‚úÖ Successfully joined game:', gameId);\n      \n      // Force refetch to ensure UI is updated with latest data\n      queryClient.refetchQueries({ queryKey: gameKeys.detail(gameId) });\n      queryClient.refetchQueries({ queryKey: gameKeys.participants(gameId) });\n      queryClient.refetchQueries({ queryKey: gameKeys.lists() });\n      \n      // Also invalidate to mark as stale\n      queryClient.invalidateQueries({ queryKey: gameKeys.detail(gameId) });\n      queryClient.invalidateQueries({ queryKey: gameKeys.participants(gameId) });\n      queryClient.invalidateQueries({ queryKey: gameKeys.lists() });\n      \n      // Toast removed - components handle their own success feedback\n    },\n  });\n}\n\n// Hook for leaving a game\nexport function useLeaveGame() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async (gameId: string) => {\n      console.log('üîß Leaving game:', gameId);\n      await SupabaseService.leaveGame(gameId);\n    },\n    onMutate: async (gameId) => {\n      // Cancel outgoing refetches for all related queries\n      await queryClient.cancelQueries({ queryKey: gameKeys.lists() });\n      await queryClient.cancelQueries({ queryKey: gameKeys.detail(gameId) });\n      await queryClient.cancelQueries({ queryKey: gameKeys.participants(gameId) });\n      \n      // Snapshot previous values\n      const previousGames = queryClient.getQueryData(gameKeys.lists());\n      const previousGame = queryClient.getQueryData(gameKeys.detail(gameId));\n      const previousParticipants = queryClient.getQueryData(gameKeys.participants(gameId));\n      \n      // Optimistically update games list\n      queryClient.setQueryData(gameKeys.lists(), (old: any) => {\n        if (!old) return old;\n        return old.map((game: any) => \n          game.id === gameId \n            ? { \n                ...game, \n                isJoined: false, \n                currentPlayers: Math.max(game.currentPlayers - 1, 0)\n              }\n            : game\n        );\n      });\n\n      // Optimistically update game detail\n      queryClient.setQueryData(gameKeys.detail(gameId), (old: any) => {\n        if (!old) return old;\n        return {\n          ...old,\n          isJoined: false,\n          currentPlayers: Math.max(old.currentPlayers - 1, 0)\n        };\n      });\n\n      // Optimistically update participants list by removing current user\n      const { user } = useAppStore.getState();\n      if (user) {\n        queryClient.setQueryData(gameKeys.participants(gameId), (old: any) => {\n          if (!old) return [];\n          return old.filter((p: any) => p.id !== user.id);\n        });\n      }\n      \n      return { previousGames, previousGame, previousParticipants };\n    },\n    onError: (error, gameId, context) => {\n      console.error('‚ùå Leave game error:', error);\n      \n      // Rollback on error\n      if (context?.previousGames) {\n        queryClient.setQueryData(gameKeys.lists(), context.previousGames);\n      }\n      if (context?.previousGame) {\n        queryClient.setQueryData(gameKeys.detail(gameId), context.previousGame);\n      }\n      if (context?.previousParticipants) {\n        queryClient.setQueryData(gameKeys.participants(gameId), context.previousParticipants);\n      }\n      \n      toast.error('Failed to leave game', {\n        description: 'Please try again later',\n      });\n    },\n    onSuccess: (_, gameId) => {\n      console.log('‚úÖ Successfully left game:', gameId);\n      \n      // Force refetch to ensure UI is updated with latest data\n      queryClient.refetchQueries({ queryKey: gameKeys.detail(gameId) });\n      queryClient.refetchQueries({ queryKey: gameKeys.participants(gameId) });\n      queryClient.refetchQueries({ queryKey: gameKeys.lists() });\n      \n      // Also invalidate to mark as stale\n      queryClient.invalidateQueries({ queryKey: gameKeys.detail(gameId) });\n      queryClient.invalidateQueries({ queryKey: gameKeys.participants(gameId) });\n      queryClient.invalidateQueries({ queryKey: gameKeys.lists() });\n      \n      // Toast removed - components handle their own success feedback\n    },\n  });\n}\n\n// Hook for creating a game\nexport function useCreateGame() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async (gameData: any) => {\n      console.log('üîß Creating game:', gameData);\n      return await SupabaseService.createGame(gameData);\n    },\n    onSuccess: (newGame) => {\n      console.log('‚úÖ Game created successfully:', newGame.id);\n      \n      // Invalidate games list to refetch\n      queryClient.invalidateQueries({ queryKey: gameKeys.lists() });\n      \n      toast.success('Game created!', {\n        description: 'Your game is now live',\n      });\n    },\n    onError: (error) => {\n      console.error('‚ùå Create game error:', error);\n      \n      toast.error('Failed to create game', {\n        description: 'Please try again later',\n      });\n    },\n  });\n}\n"],"names":["gameKeys","all","lists","list","filters","details","detail","id","participants","useGames","user","useAppStore","useQuery","queryKey","queryFn","async","SupabaseService","getGames","staleTime","gcTime","useGame","gameId","getGameById","enabled","useGameParticipants","getGameParticipants","useJoinGame","queryClient","useQueryClient","useMutation","mutationFn","joinGame","onMutate","cancelQueries","previousGames","getQueryData","previousGame","previousParticipants","setQueryData","old","map","game","isJoined","currentPlayers","Math","min","maxPlayers","name","avatar","some","p","onError","error","context","toast","description","onSuccess","_","refetchQueries","invalidateQueries","useLeaveGame","leaveGame","max","getState","filter"],"mappings":"4IAMO,MAAMA,EAAW,CACtBC,IAAK,CAAC,SACNC,MAAO,IAAM,IAAIF,EAASC,IAAK,QAC/BE,KAAOC,GAAiC,IAAIJ,EAASE,QAAS,CAAEE,YAChEC,QAAS,IAAM,IAAIL,EAASC,IAAK,UACjCK,OAASC,GAAe,IAAIP,EAASK,UAAWE,GAChDC,aAAeD,GAAe,IAAIP,EAASM,OAAOC,GAAK,iBAIlD,SAASE,IACd,MAAMC,KAAEA,GAASC,IAEjB,OAAOC,EAAS,CACdC,SAAUb,EAASE,QACnBY,QAASC,eAEaC,EAAgBC,WAItCC,UAAW,KACXC,OAAQ,KAIZ,CAGO,SAASC,EAAQC,GACtB,OAAOT,EAAS,CACdC,SAAUb,EAASM,OAAOe,GAC1BP,QAASC,eACMC,EAAgBM,YAAYD,GAE3CE,UAAWF,GAEf,CAGO,SAASG,EAAoBH,GAClC,OAAOT,EAAS,CACdC,SAAUb,EAASQ,aAAaa,GAChCP,QAAS,IAAME,EAAgBS,oBAAoBJ,GACnDE,UAAWF,EACXH,UAAW,KAEf,CAGO,SAASQ,IACd,MAAMC,EAAcC,KACdlB,KAAEA,GAASC,IAEjB,OAAOkB,EAAY,CACjBC,WAAYf,MAAOM,UAEXL,EAAgBe,SAASV,IAEjCW,SAAUjB,MAAOM,UAETM,EAAYM,cAAc,CAAEpB,SAAUb,EAASE,gBAC/CyB,EAAYM,cAAc,CAAEpB,SAAUb,EAASM,OAAOe,WACtDM,EAAYM,cAAc,CAAEpB,SAAUb,EAASQ,aAAaa,KAGlE,MAAMa,EAAgBP,EAAYQ,aAAanC,EAASE,SAClDkC,EAAeT,EAAYQ,aAAanC,EAASM,OAAOe,IACxDgB,EAAuBV,EAAYQ,aAAanC,EAASQ,aAAaa,IAoC5E,OAjCAM,EAAYW,aAAatC,EAASE,QAAUqC,GACrCA,EACEA,EAAIC,IAAKC,GACdA,EAAKlC,KAAOc,EACR,IACKoB,EACHC,UAAU,EACVC,eAAgBC,KAAKC,IAAIJ,EAAKE,eAAiB,EAAGF,EAAKK,aAEzDL,GARWF,GAanBZ,EAAYW,aAAatC,EAASM,OAAOe,GAAUkB,GAC5CA,EACE,IACFA,EACHG,UAAU,EACVC,eAAgBC,KAAKC,IAAIN,EAAII,eAAiB,EAAGJ,EAAIO,aAJtCP,GASf7B,GACFiB,EAAYW,aAAatC,EAASQ,aAAaa,GAAUkB,IACvD,IAAKA,EAAK,MAAO,CAAC,CAAEhC,GAAIG,EAAKH,GAAIwC,KAAMrC,EAAKqC,KAAMC,OAAQtC,EAAKsC,SAE/D,OADwBT,EAAIU,KAAMC,GAAWA,EAAE3C,KAAOG,EAAKH,IAC/BgC,EACrB,IAAIA,EAAK,CAAEhC,GAAIG,EAAKH,GAAIwC,KAAMrC,EAAKqC,KAAMC,OAAQtC,EAAKsC,WAI1D,CAAEd,gBAAeE,eAAcC,yBAExCc,QAAS,CAACC,EAAO/B,EAAQgC,KAInBA,GAASnB,eACXP,EAAYW,aAAatC,EAASE,QAASmD,EAAQnB,eAEjDmB,GAASjB,cACXT,EAAYW,aAAatC,EAASM,OAAOe,GAASgC,EAAQjB,cAExDiB,GAAShB,sBACXV,EAAYW,aAAatC,EAASQ,aAAaa,GAASgC,EAAQhB,sBAGlEiB,EAAMF,MAAM,sBAAuB,CACjCG,YAAa,4BAGjBC,UAAW,CAACC,EAAGpC,KAIbM,EAAY+B,eAAe,CAAE7C,SAAUb,EAASM,OAAOe,KACvDM,EAAY+B,eAAe,CAAE7C,SAAUb,EAASQ,aAAaa,KAC7DM,EAAY+B,eAAe,CAAE7C,SAAUb,EAASE,UAGhDyB,EAAYgC,kBAAkB,CAAE9C,SAAUb,EAASM,OAAOe,KAC1DM,EAAYgC,kBAAkB,CAAE9C,SAAUb,EAASQ,aAAaa,KAChEM,EAAYgC,kBAAkB,CAAE9C,SAAUb,EAASE,YAKzD,CAGO,SAAS0D,IACd,MAAMjC,EAAcC,IAEpB,OAAOC,EAAY,CACjBC,WAAYf,MAAOM,UAEXL,EAAgB6C,UAAUxC,IAElCW,SAAUjB,MAAOM,UAETM,EAAYM,cAAc,CAAEpB,SAAUb,EAASE,gBAC/CyB,EAAYM,cAAc,CAAEpB,SAAUb,EAASM,OAAOe,WACtDM,EAAYM,cAAc,CAAEpB,SAAUb,EAASQ,aAAaa,KAGlE,MAAMa,EAAgBP,EAAYQ,aAAanC,EAASE,SAClDkC,EAAeT,EAAYQ,aAAanC,EAASM,OAAOe,IACxDgB,EAAuBV,EAAYQ,aAAanC,EAASQ,aAAaa,IAG5EM,EAAYW,aAAatC,EAASE,QAAUqC,GACrCA,EACEA,EAAIC,IAAKC,GACdA,EAAKlC,KAAOc,EACR,IACKoB,EACHC,UAAU,EACVC,eAAgBC,KAAKkB,IAAIrB,EAAKE,eAAiB,EAAG,IAEpDF,GARWF,GAanBZ,EAAYW,aAAatC,EAASM,OAAOe,GAAUkB,GAC5CA,EACE,IACFA,EACHG,UAAU,EACVC,eAAgBC,KAAKkB,IAAIvB,EAAII,eAAiB,EAAG,IAJlCJ,GASnB,MAAM7B,KAAEA,GAASC,EAAYoD,WAQ7B,OAPIrD,GACFiB,EAAYW,aAAatC,EAASQ,aAAaa,GAAUkB,GAClDA,EACEA,EAAIyB,OAAQd,GAAWA,EAAE3C,KAAOG,EAAKH,IAD3B,IAKd,CAAE2B,gBAAeE,eAAcC,yBAExCc,QAAS,CAACC,EAAO/B,EAAQgC,KAInBA,GAASnB,eACXP,EAAYW,aAAatC,EAASE,QAASmD,EAAQnB,eAEjDmB,GAASjB,cACXT,EAAYW,aAAatC,EAASM,OAAOe,GAASgC,EAAQjB,cAExDiB,GAAShB,sBACXV,EAAYW,aAAatC,EAASQ,aAAaa,GAASgC,EAAQhB,sBAGlEiB,EAAMF,MAAM,uBAAwB,CAClCG,YAAa,4BAGjBC,UAAW,CAACC,EAAGpC,KAIbM,EAAY+B,eAAe,CAAE7C,SAAUb,EAASM,OAAOe,KACvDM,EAAY+B,eAAe,CAAE7C,SAAUb,EAASQ,aAAaa,KAC7DM,EAAY+B,eAAe,CAAE7C,SAAUb,EAASE,UAGhDyB,EAAYgC,kBAAkB,CAAE9C,SAAUb,EAASM,OAAOe,KAC1DM,EAAYgC,kBAAkB,CAAE9C,SAAUb,EAASQ,aAAaa,KAChEM,EAAYgC,kBAAkB,CAAE9C,SAAUb,EAASE,YAKzD"}