{"version":3,"file":"useGames-BZdFMUUb.js","sources":["../../src/utils/cacheCorruptionDetector.ts","../../src/hooks/useGames.ts"],"sourcesContent":["/**\n * Browser Cache Corruption Detection and Recovery\n * \n * This addresses the root cause: corrupted browser storage that causes\n * infinite loading by serving bad cached responses to React Query.\n */\n\nexport class CacheCorruptionDetector {\n  private static readonly CORRUPTION_MARKERS = {\n    LAST_SUCCESSFUL_LOAD: 'tribeup_last_successful_load',\n    CORRUPTION_COUNT: 'tribeup_corruption_count',\n    FORCE_CLEAN_FLAG: 'tribeup_force_clean',\n    APP_VERSION: 'tribeup_app_version'\n  };\n\n  private static readonly MAX_CORRUPTION_COUNT = 3;\n  private static readonly CORRUPTION_TIMEOUT = 30000; // 30 seconds\n  private static readonly CURRENT_VERSION = '1.0.0';\n\n  /**\n   * Detect if browser cache is corrupted based on loading behavior\n   */\n  static async detectCorruption(): Promise<boolean> {\n    console.log('üîç [CacheCorruption] Starting corruption detection...');\n\n    const indicators = {\n      hasForceCleanFlag: this.hasForceCleanFlag(),\n      hasVersionMismatch: this.hasVersionMismatch(),\n      hasRepeatedFailures: this.hasRepeatedFailures(),\n      hasStaleAuthTokens: await this.hasStaleAuthTokens(),\n      hasCorruptedStorage: this.hasCorruptedStorage()\n    };\n\n    console.log('üìä [CacheCorruption] Indicators:', indicators);\n\n    // If any major indicator is true, we have corruption\n    const isCorrupted = Object.values(indicators).some(Boolean);\n    \n    if (isCorrupted) {\n      console.warn('üö® [CacheCorruption] Cache corruption detected!');\n      this.incrementCorruptionCount();\n    } else {\n      console.log('‚úÖ [CacheCorruption] No corruption detected');\n      this.resetCorruptionCount();\n    }\n\n    return isCorrupted;\n  }\n\n  /**\n   * Clean all browser storage and caches\n   */\n  static async cleanAllCaches(): Promise<void> {\n    console.log('üßπ [CacheCorruption] Starting comprehensive cache cleanup...');\n\n    try {\n      // 1. Clear localStorage (Supabase auth, app data)\n      const localStorageKeys = Object.keys(localStorage);\n      localStorageKeys.forEach(key => {\n        if (key.startsWith('supabase') || key.startsWith('tribeup') || key.startsWith('sb-')) {\n          localStorage.removeItem(key);\n          console.log(`üóëÔ∏è Cleared localStorage: ${key}`);\n        }\n      });\n\n      // 2. Clear sessionStorage\n      sessionStorage.clear();\n      console.log('üóëÔ∏è Cleared sessionStorage');\n\n      // 3. Clear IndexedDB (if accessible)\n      try {\n        if ('indexedDB' in window) {\n          // Clear common IndexedDB databases\n          const dbNames = ['supabase-cache', 'workbox-precache', 'tribeup-cache'];\n          for (const dbName of dbNames) {\n            try {\n              indexedDB.deleteDatabase(dbName);\n              console.log(`üóëÔ∏è Cleared IndexedDB: ${dbName}`);\n            } catch (e) {\n              console.warn(`‚ö†Ô∏è Could not clear IndexedDB ${dbName}:`, e);\n            }\n          }\n        }\n      } catch (e) {\n        console.warn('‚ö†Ô∏è IndexedDB cleanup failed:', e);\n      }\n\n      // 4. Clear Service Worker caches\n      if ('caches' in window) {\n        try {\n          const cacheNames = await caches.keys();\n          await Promise.all(\n            cacheNames.map(async (cacheName) => {\n              await caches.delete(cacheName);\n              console.log(`üóëÔ∏è Cleared cache: ${cacheName}`);\n            })\n          );\n        } catch (e) {\n          console.warn('‚ö†Ô∏è Service Worker cache cleanup failed:', e);\n        }\n      }\n\n      // 5. Unregister Service Workers\n      if ('serviceWorker' in navigator) {\n        try {\n          const registrations = await navigator.serviceWorker.getRegistrations();\n          await Promise.all(\n            registrations.map(async (registration) => {\n              await registration.unregister();\n              console.log('üóëÔ∏è Unregistered Service Worker');\n            })\n          );\n        } catch (e) {\n          console.warn('‚ö†Ô∏è Service Worker unregistration failed:', e);\n        }\n      }\n\n      // 6. Set markers for successful cleanup\n      this.markSuccessfulLoad();\n      this.setAppVersion();\n      \n      console.log('‚úÖ [CacheCorruption] Cache cleanup completed');\n\n    } catch (error) {\n      console.error('‚ùå [CacheCorruption] Cache cleanup failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if force clean flag is set\n   */\n  private static hasForceCleanFlag(): boolean {\n    return localStorage.getItem(this.CORRUPTION_MARKERS.FORCE_CLEAN_FLAG) === 'true';\n  }\n\n  /**\n   * Check if app version has changed (indicates potential cache conflicts)\n   */\n  private static hasVersionMismatch(): boolean {\n    const storedVersion = localStorage.getItem(this.CORRUPTION_MARKERS.APP_VERSION);\n    return storedVersion !== null && storedVersion !== this.CURRENT_VERSION;\n  }\n\n  /**\n   * Check if we've had repeated loading failures\n   */\n  private static hasRepeatedFailures(): boolean {\n    const count = parseInt(localStorage.getItem(this.CORRUPTION_MARKERS.CORRUPTION_COUNT) || '0');\n    return count >= this.MAX_CORRUPTION_COUNT;\n  }\n\n  /**\n   * Check if Supabase auth tokens are stale or corrupted\n   */\n  private static async hasStaleAuthTokens(): Promise<boolean> {\n    try {\n      const authKeys = Object.keys(localStorage).filter(key => \n        key.startsWith('supabase') || key.startsWith('sb-')\n      );\n\n      for (const key of authKeys) {\n        const value = localStorage.getItem(key);\n        if (value) {\n          try {\n            const parsed = JSON.parse(value);\n            // Check for malformed auth data\n            if (parsed.access_token && typeof parsed.access_token !== 'string') {\n              return true;\n            }\n            if (parsed.expires_at && isNaN(new Date(parsed.expires_at * 1000).getTime())) {\n              return true;\n            }\n          } catch (e) {\n            // JSON parse error indicates corruption\n            return true;\n          }\n        }\n      }\n      return false;\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Auth token check failed:', error);\n      return true; // Assume corruption if we can't check\n    }\n  }\n\n  /**\n   * Check for general localStorage corruption\n   */\n  private static hasCorruptedStorage(): boolean {\n    try {\n      // Test localStorage functionality\n      const testKey = 'tribeup_storage_test';\n      const testValue = 'test_value_' + Date.now();\n      \n      localStorage.setItem(testKey, testValue);\n      const retrieved = localStorage.getItem(testKey);\n      localStorage.removeItem(testKey);\n      \n      return retrieved !== testValue;\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Storage corruption test failed:', error);\n      return true;\n    }\n  }\n\n  /**\n   * Mark successful app load\n   */\n  private static markSuccessfulLoad(): void {\n    localStorage.setItem(this.CORRUPTION_MARKERS.LAST_SUCCESSFUL_LOAD, Date.now().toString());\n  }\n\n  /**\n   * Set current app version\n   */\n  private static setAppVersion(): void {\n    localStorage.setItem(this.CORRUPTION_MARKERS.APP_VERSION, this.CURRENT_VERSION);\n  }\n\n  /**\n   * Increment corruption count\n   */\n  private static incrementCorruptionCount(): void {\n    const current = parseInt(localStorage.getItem(this.CORRUPTION_MARKERS.CORRUPTION_COUNT) || '0');\n    localStorage.setItem(this.CORRUPTION_MARKERS.CORRUPTION_COUNT, (current + 1).toString());\n  }\n\n  /**\n   * Reset corruption count on successful operation\n   */\n  private static resetCorruptionCount(): void {\n    localStorage.removeItem(this.CORRUPTION_MARKERS.CORRUPTION_COUNT);\n  }\n\n  /**\n   * Force cache cleanup on next load\n   */\n  static forceCleanOnNextLoad(): void {\n    localStorage.setItem(this.CORRUPTION_MARKERS.FORCE_CLEAN_FLAG, 'true');\n    console.log('üö® [CacheCorruption] Force clean flag set for next load');\n  }\n\n  /**\n   * Clear force clean flag\n   */\n  private static clearForceCleanFlag(): void {\n    localStorage.removeItem(this.CORRUPTION_MARKERS.FORCE_CLEAN_FLAG);\n  }\n\n  /**\n   * Auto-detect and clean if corruption is found\n   */\n  static async autoDetectAndClean(): Promise<boolean> {\n    const isCorrupted = await this.detectCorruption();\n    \n    if (isCorrupted) {\n      console.warn('üö® [CacheCorruption] Auto-cleaning corrupted cache...');\n      await this.cleanAllCaches();\n      this.clearForceCleanFlag();\n      return true;\n    }\n    \n    return false;\n  }\n}\n\n// Global access for debugging\nif (typeof window !== 'undefined') {\n  (window as any).cacheCorruptionDetector = CacheCorruptionDetector;\n  (window as any).forceCleanCache = () => CacheCorruptionDetector.forceCleanOnNextLoad();\n}\n","import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useEffect } from 'react';\nimport { SupabaseService } from '../lib/supabaseService';\nimport { useAppStore } from '../store/appStore';\nimport { toast } from 'sonner';\nimport { CacheCorruptionDetector } from '../utils/cacheCorruptionDetector';\n\n// Query keys\nexport const gameKeys = {\n  all: ['games'] as const,\n  lists: () => [...gameKeys.all, 'list'] as const,\n  list: (filters: Record<string, any>) => [...gameKeys.lists(), { filters }] as const,\n  details: () => [...gameKeys.all, 'detail'] as const,\n  detail: (id: string) => [...gameKeys.details(), id] as const,\n  participants: (id: string) => [...gameKeys.detail(id), 'participants'] as const,\n};\n\n// Hook for fetching games with enhanced error handling and timeout\nexport function useGames() {\n  const { user } = useAppStore();\n  const queryClient = useQueryClient();\n  \n  // Invalidate cache when user auth state changes to prevent stale data\n  useEffect(() => {\n    console.log('üîÑ [useGames] Auth state changed, invalidating cache for user:', user?.id || 'anonymous');\n    \n    // Clear stale cache completely when auth state changes\n    queryClient.removeQueries({ \n      queryKey: gameKeys.lists(),\n      predicate: (query) => query.isStale()\n    });\n    \n    // Force fresh fetch\n    queryClient.invalidateQueries({ queryKey: gameKeys.lists() });\n  }, [user?.id, queryClient]);\n  \n  return useQuery({\n    queryKey: gameKeys.lists(),\n    queryFn: async () => {\n      console.log('üîç [useGames] Starting fetch with user:', user?.id || 'anonymous');\n      const startTime = performance.now();\n      \n      try {\n        // Let the query complete naturally - no artificial timeouts\n        const games = await SupabaseService.getGames();\n        const duration = performance.now() - startTime;\n        \n        console.log('‚úÖ [useGames] Games fetched successfully:', {\n          count: games.length,\n          duration: `${duration.toFixed(2)}ms`,\n          user: user?.id || 'anonymous'\n        });\n        \n        return games;\n      } catch (error) {\n        const duration = performance.now() - startTime;\n        console.error('‚ùå [useGames] Fetch failed:', {\n          error: error.message,\n          duration: `${duration.toFixed(2)}ms`,\n          user: user?.id || 'anonymous'\n        });\n        \n        // If it's a timeout, this might be cache corruption\n        if (error.message?.includes('timeout')) {\n          console.warn('üßπ [useGames] Timeout detected - possible cache corruption');\n          \n          // After 2 timeouts, assume cache corruption and force clean\n          const timeoutCount = parseInt(sessionStorage.getItem('tribeup_timeout_count') || '0') + 1;\n          sessionStorage.setItem('tribeup_timeout_count', timeoutCount.toString());\n          \n          if (timeoutCount >= 2) {\n            console.error('üö® [useGames] Multiple timeouts detected, forcing cache cleanup');\n            CacheCorruptionDetector.forceCleanOnNextLoad();\n            toast.error('Loading issues detected', {\n              description: 'Refreshing to clear corrupted cache...',\n              duration: 3000\n            });\n            \n            setTimeout(() => {\n              window.location.reload();\n            }, 3000);\n          }\n        }\n        \n        throw error;\n      }\n    },\n    staleTime: 2 * 60 * 1000, // 2 minutes (reasonable refresh time)\n    gcTime: 5 * 60 * 1000, // 5 minutes (normal cleanup)\n    retry: (failureCount, error) => {\n      console.log(`üîÑ [useGames] Retry attempt ${failureCount}:`, error.message);\n      \n      // Don't retry timeouts more than once\n      if (error.message?.includes('timeout') && failureCount >= 1) {\n        console.warn('üö´ [useGames] Timeout retry limit reached');\n        return false;\n      }\n      \n      // Don't retry auth errors\n      if (error.message?.includes('JWT') || error.message?.includes('auth')) {\n        console.warn('üö´ [useGames] Auth error, no retry');\n        return false;\n      }\n      \n      return failureCount < 2; // Max 2 retries\n    },\n    retryDelay: (attemptIndex) => {\n      const delay = Math.min(1000 * Math.pow(2, attemptIndex), 5000);\n      console.log(`‚è±Ô∏è [useGames] Retry delay: ${delay}ms`);\n      return delay;\n    },\n    // Remove authentication requirement - games should load for all users\n    // enabled: !!user, // Only fetch when user is authenticated\n    refetchOnMount: false, // Don't refetch on every mount - use cache\n    refetchOnWindowFocus: false, // Don't refetch on window focus - reduces queries\n    refetchOnReconnect: true, // Only refetch when network reconnects\n    meta: {\n      errorMessage: 'Failed to load games. Please refresh the page.'\n    }\n  });\n}\n\n// Hook for fetching a single game\nexport function useGame(gameId: string) {\n  return useQuery({\n    queryKey: gameKeys.detail(gameId),\n    queryFn: async () => {\n      console.log('üîç Fetching game:', gameId);\n      const game = await SupabaseService.getGameById(gameId);\n      console.log('‚úÖ Game fetched:', game?.id || 'not found');\n      return game;\n    },\n    enabled: !!gameId,\n    staleTime: 2 * 60 * 1000, // 2 minutes\n    gcTime: 5 * 60 * 1000, // 5 minutes\n    retry: 3,\n    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    meta: {\n      errorMessage: 'Failed to load game details'\n    }\n  });\n}\n\n// Hook for fetching game participants\nexport function useGameParticipants(gameId: string) {\n  return useQuery({\n    queryKey: gameKeys.participants(gameId),\n    queryFn: async () => {\n      console.log('üîç Fetching participants for game:', gameId);\n      const participants = await SupabaseService.getGameParticipants(gameId);\n      console.log('‚úÖ Participants fetched:', participants.length);\n      return participants;\n    },\n    enabled: !!gameId,\n    staleTime: 1 * 60 * 1000, // 1 minute\n    gcTime: 5 * 60 * 1000, // 5 minutes\n    retry: 3,\n    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    meta: {\n      errorMessage: 'Failed to load game participants'\n    }\n  });\n}\n\n// Hook for joining a game\nexport function useJoinGame() {\n  const queryClient = useQueryClient();\n  const { user } = useAppStore();\n\n  return useMutation({\n    mutationFn: async (gameId: string) => {\n      console.log('üîß Joining game:', gameId);\n      await SupabaseService.joinGame(gameId);\n    },\n    onMutate: async (gameId) => {\n      // Cancel outgoing refetches for all related queries\n      await queryClient.cancelQueries({ queryKey: gameKeys.lists() });\n      await queryClient.cancelQueries({ queryKey: gameKeys.detail(gameId) });\n      await queryClient.cancelQueries({ queryKey: gameKeys.participants(gameId) });\n      \n      // Snapshot previous values\n      const previousGames = queryClient.getQueryData(gameKeys.lists());\n      const previousGame = queryClient.getQueryData(gameKeys.detail(gameId));\n      const previousParticipants = queryClient.getQueryData(gameKeys.participants(gameId));\n      \n      // Optimistically update games list\n      queryClient.setQueryData(gameKeys.lists(), (old: any) => {\n        if (!old) return old;\n        return old.map((game: any) => \n          game.id === gameId \n            ? { \n                ...game, \n                isJoined: true, \n                currentPlayers: Math.min(game.currentPlayers + 1, game.maxPlayers)\n              }\n            : game\n        );\n      });\n\n      // Optimistically update game detail\n      queryClient.setQueryData(gameKeys.detail(gameId), (old: any) => {\n        if (!old) return old;\n        return {\n          ...old,\n          isJoined: true,\n          currentPlayers: Math.min(old.currentPlayers + 1, old.maxPlayers)\n        };\n      });\n\n      // Optimistically update participants list\n      if (user) {\n        queryClient.setQueryData(gameKeys.participants(gameId), (old: any) => {\n          if (!old) return [{ id: user.id, name: user.name, avatar: user.avatar }];\n          const isAlreadyJoined = old.some((p: any) => p.id === user.id);\n          if (isAlreadyJoined) return old;\n          return [...old, { id: user.id, name: user.name, avatar: user.avatar }];\n        });\n      }\n      \n      return { previousGames, previousGame, previousParticipants };\n    },\n    onError: (error, gameId, context) => {\n      console.error('‚ùå Join game error:', error);\n      \n      // Rollback on error\n      if (context?.previousGames) {\n        queryClient.setQueryData(gameKeys.lists(), context.previousGames);\n      }\n      if (context?.previousGame) {\n        queryClient.setQueryData(gameKeys.detail(gameId), context.previousGame);\n      }\n      if (context?.previousParticipants) {\n        queryClient.setQueryData(gameKeys.participants(gameId), context.previousParticipants);\n      }\n      \n      toast.error('Failed to join game', {\n        description: 'Please try again later',\n      });\n    },\n    onSuccess: (_, gameId) => {\n      console.log('‚úÖ Successfully joined game:', gameId);\n      \n      // Just invalidate - let React Query handle the refetch automatically\n      // This prevents race conditions between optimistic updates and refetches\n      queryClient.invalidateQueries({ queryKey: gameKeys.detail(gameId) });\n      queryClient.invalidateQueries({ queryKey: gameKeys.participants(gameId) });\n      queryClient.invalidateQueries({ queryKey: gameKeys.lists() });\n      \n      console.log('üîÑ Invalidated queries for game:', gameId);\n    },\n  });\n}\n\n// Hook for leaving a game\nexport function useLeaveGame() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async (gameId: string) => {\n      console.log('üîß Leaving game:', gameId);\n      await SupabaseService.leaveGame(gameId);\n    },\n    onMutate: async (gameId) => {\n      // Cancel outgoing refetches for all related queries\n      await queryClient.cancelQueries({ queryKey: gameKeys.lists() });\n      await queryClient.cancelQueries({ queryKey: gameKeys.detail(gameId) });\n      await queryClient.cancelQueries({ queryKey: gameKeys.participants(gameId) });\n      \n      // Snapshot previous values\n      const previousGames = queryClient.getQueryData(gameKeys.lists());\n      const previousGame = queryClient.getQueryData(gameKeys.detail(gameId));\n      const previousParticipants = queryClient.getQueryData(gameKeys.participants(gameId));\n      \n      // Optimistically update games list\n      queryClient.setQueryData(gameKeys.lists(), (old: any) => {\n        if (!old) return old;\n        return old.map((game: any) => \n          game.id === gameId \n            ? { \n                ...game, \n                isJoined: false, \n                currentPlayers: Math.max(game.currentPlayers - 1, 0)\n              }\n            : game\n        );\n      });\n\n      // Optimistically update game detail\n      queryClient.setQueryData(gameKeys.detail(gameId), (old: any) => {\n        if (!old) return old;\n        return {\n          ...old,\n          isJoined: false,\n          currentPlayers: Math.max(old.currentPlayers - 1, 0)\n        };\n      });\n\n      // Optimistically update participants list by removing current user\n      const { user } = useAppStore.getState();\n      if (user) {\n        queryClient.setQueryData(gameKeys.participants(gameId), (old: any) => {\n          if (!old) return [];\n          return old.filter((p: any) => p.id !== user.id);\n        });\n      }\n      \n      return { previousGames, previousGame, previousParticipants };\n    },\n    onError: (error, gameId, context) => {\n      console.error('‚ùå Leave game error:', error);\n      \n      // Rollback on error\n      if (context?.previousGames) {\n        queryClient.setQueryData(gameKeys.lists(), context.previousGames);\n      }\n      if (context?.previousGame) {\n        queryClient.setQueryData(gameKeys.detail(gameId), context.previousGame);\n      }\n      if (context?.previousParticipants) {\n        queryClient.setQueryData(gameKeys.participants(gameId), context.previousParticipants);\n      }\n      \n      toast.error('Failed to leave game', {\n        description: 'Please try again later',\n      });\n    },\n    onSuccess: (_, gameId) => {\n      console.log('‚úÖ Successfully left game:', gameId);\n      \n      // Just invalidate - let React Query handle the refetch automatically\n      // This prevents race conditions between optimistic updates and refetches\n      queryClient.invalidateQueries({ queryKey: gameKeys.detail(gameId) });\n      queryClient.invalidateQueries({ queryKey: gameKeys.participants(gameId) });\n      queryClient.invalidateQueries({ queryKey: gameKeys.lists() });\n      \n      console.log('üîÑ Invalidated queries for game:', gameId);\n    },\n  });\n}\n\n// Hook for creating a game\nexport function useCreateGame() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async (gameData: any) => {\n      console.log('üîß Creating game:', gameData);\n      return await SupabaseService.createGame(gameData);\n    },\n    onSuccess: (newGame) => {\n      console.log('‚úÖ Game created successfully:', newGame?.id || 'unknown');\n      \n      // Invalidate games list to refetch\n      queryClient.invalidateQueries({ queryKey: gameKeys.lists() });\n      \n      toast.success('Game created!', {\n        description: 'Your game is now live',\n      });\n    },\n    onError: (error) => {\n      console.error('‚ùå Create game error:', error);\n      \n      toast.error('Failed to create game', {\n        description: 'Please try again later',\n      });\n    },\n  });\n}\n"],"names":["CacheCorruptionDetector","static","LAST_SUCCESSFUL_LOAD","CORRUPTION_COUNT","FORCE_CLEAN_FLAG","APP_VERSION","detectCorruption","indicators","hasForceCleanFlag","this","hasVersionMismatch","hasRepeatedFailures","hasStaleAuthTokens","hasCorruptedStorage","isCorrupted","Object","values","some","Boolean","incrementCorruptionCount","resetCorruptionCount","cleanAllCaches","keys","localStorage","forEach","key","startsWith","removeItem","sessionStorage","clear","window","dbNames","dbName","indexedDB","deleteDatabase","e","cacheNames","caches","Promise","all","map","async","cacheName","delete","navigator","registrations","serviceWorker","getRegistrations","registration","unregister","markSuccessfulLoad","setAppVersion","error","getItem","CORRUPTION_MARKERS","storedVersion","CURRENT_VERSION","parseInt","MAX_CORRUPTION_COUNT","authKeys","filter","value","parsed","JSON","parse","access_token","expires_at","isNaN","Date","getTime","testKey","testValue","now","setItem","retrieved","toString","current","forceCleanOnNextLoad","clearForceCleanFlag","autoDetectAndClean","cacheCorruptionDetector","forceCleanCache","gameKeys","lists","list","filters","details","detail","id","participants","useGames","user","useAppStore","queryClient","useQueryClient","useEffect","removeQueries","queryKey","predicate","query","isStale","invalidateQueries","useQuery","queryFn","startTime","performance","games","SupabaseService","getGames","message","includes","timeoutCount","toast","description","duration","setTimeout","location","reload","staleTime","gcTime","retry","failureCount","retryDelay","attemptIndex","Math","min","pow","refetchOnMount","refetchOnWindowFocus","refetchOnReconnect","meta","errorMessage","useGame","gameId","getGameById","enabled","useGameParticipants","getGameParticipants","useJoinGame","useMutation","mutationFn","joinGame","onMutate","cancelQueries","previousGames","getQueryData","previousGame","previousParticipants","setQueryData","old","game","isJoined","currentPlayers","maxPlayers","name","avatar","p","onError","context","onSuccess","_","useLeaveGame","leaveGame","max","getState"],"mappings":"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"}