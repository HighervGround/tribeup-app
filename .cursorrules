# TribeUp Social Sports App - AI Code Generation Rules

## Project Overview
TribeUp is a sports activity coordination platform built with React, TypeScript, Vite, and Supabase. The app enables users to create, discover, and join sports games with real-time updates, weather integration, and location-based recommendations.

## Architecture Philosophy
- **Domain-Driven Design**: Code is organized by business domain (games, weather, locations, users)
- **Component-First**: React components are the primary building blocks
- **Real-time First**: Supabase Realtime for live updates
- **Mobile-First**: Responsive design with mobile as primary target

## Tech Stack
- **Frontend**: React 18 + TypeScript + Vite
- **Styling**: Tailwind CSS + Radix UI components
- **State Management**: Zustand + React Query
- **Backend**: Supabase (PostgreSQL + Auth + Realtime + Storage)
- **Routing**: React Router v6
- **Maps**: Google Maps JavaScript API
- **Weather**: WeatherAPI.com

## Project Structure

```
src/
├── domains/              # Business domains (feature-based organization)
│   ├── games/           # Game Management System (core feature)
│   ├── weather/         # Weather Integration
│   ├── locations/       # Location Services
│   └── users/           # User Engagement
│
├── shared/              # Shared across domains
│   ├── components/      # Reusable UI components
│   │   ├── ui/         # Radix UI primitives
│   │   ├── layout/     # Layout components
│   │   └── common/     # Common components
│   ├── hooks/          # Shared hooks
│   └── utils/          # Utility functions
│
├── core/               # App infrastructure
│   ├── auth/          # Authentication & authorization
│   ├── config/        # Environment & system config
│   ├── database/      # Supabase client & types
│   ├── routing/       # App routing
│   └── notifications/ # Notification system
│
├── store/             # Global state (Zustand)
├── App.tsx            # Root component
└── main.tsx           # App entry point
```

## Code Generation Guidelines

### Import Paths
**ALWAYS use `@/` path aliases** instead of relative imports:

```typescript
// ✅ CORRECT
import { supabase } from '@/core/database/supabase';
import { Button } from '@/shared/components/ui/button';
import { useGameActions } from '@/domains/games/hooks/useGameActions';

// ❌ INCORRECT
import { supabase } from '../../../core/database/supabase';
import { Button } from '../../shared/components/ui/button';
```

### Component Conventions
- Use functional components with TypeScript
- Use named exports for components
- Props interfaces should be exported
- Use React Query for server state
- Use Zustand for client state
- Implement error boundaries for domains

```typescript
// Component template
interface MyComponentProps {
  gameId: string;
  onSuccess?: () => void;
}

export const MyComponent = ({ gameId, onSuccess }: MyComponentProps) => {
  // Hooks at the top
  const { data, isLoading } = useQuery(/*...*/);
  
  // Event handlers
  const handleClick = () => {
    // logic
  };
  
  // Render
  if (isLoading) return <Skeleton />;
  
  return (
    <div>
      {/* JSX */}
    </div>
  );
};
```

### Hook Conventions
- Custom hooks start with `use`
- Return objects with clear names
- Include loading, error, and data states
- Use React Query for data fetching
- Memoize expensive computations

```typescript
// Hook template
export const useGameData = (gameId: string) => {
  return useQuery({
    queryKey: ['game', gameId],
    queryFn: () => fetchGame(gameId),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};
```

### Service Conventions
- Pure functions for business logic
- Handle errors explicitly
- Return consistent response shapes
- Use Supabase client from `@/core/database/supabase`

```typescript
// Service template
export const createGame = async (gameData: GameInput): Promise<Game> => {
  const { data, error } = await supabase
    .from('games')
    .insert(gameData)
    .select()
    .single();
    
  if (error) throw error;
  return data;
};
```

## Domain-Specific Guidelines

### Games Domain (`src/domains/games/`)
- Primary domain, highest complexity
- Use optimistic updates for join/leave
- Implement real-time subscriptions for active games
- Handle timing restrictions (2-hour rule)
- See `src/domains/games/README.md` for details

### Weather Domain (`src/domains/weather/`)
- Cache weather data for 30 minutes
- Sport-specific suitability scoring
- 4-hour window analysis
- See `src/domains/weather/README.md` for details

### Locations Domain (`src/domains/locations/`)
- Use Haversine formula for distances
- Implement map clustering for performance
- Cache location searches
- See `src/domains/locations/README.md` for details

### Users Domain (`src/domains/users/`)
- Handle onboarding flow carefully
- Track achievements via database triggers
- Respect privacy settings
- See `src/domains/users/README.md` for details

## Supabase Patterns

### Real-time Subscriptions
```typescript
useEffect(() => {
  const channel = supabase
    .channel(`game:${gameId}`)
    .on('postgres_changes', 
      { event: '*', schema: 'public', table: 'games', filter: `id=eq.${gameId}` },
      (payload) => {
        // Handle update
      }
    )
    .subscribe();
    
  return () => {
    supabase.removeChannel(channel);
  };
}, [gameId]);
```

### Row Level Security (RLS)
- All tables have RLS enabled
- Auth context from `auth.uid()`
- Public RSVP view for unauthenticated access
- Policy naming: `{table}_{action}_{subject}`

### Query Patterns
```typescript
// Use React Query with Supabase
const { data } = useQuery({
  queryKey: ['games', { sport, location }],
  queryFn: async () => {
    const { data, error } = await supabase
      .from('games')
      .select('*, creator:user_profiles!created_by(*), participants:game_participants(*)')
      .eq('sport', sport)
      .gte('date', new Date().toISOString())
      .order('date', { ascending: true })
      .limit(20);
      
    if (error) throw error;
    return data;
  },
});
```

## Styling Guidelines
- Use Tailwind CSS utility classes
- Use Radix UI for complex components
- Mobile-first responsive design
- Dark mode support via next-themes
- Use `cn()` utility for conditional classes

```typescript
import { cn } from '@/shared/utils/utils';

<div className={cn(
  "base classes here",
  condition && "conditional classes",
  anotherCondition ? "true classes" : "false classes"
)} />
```

## Error Handling
- Use try/catch in async functions
- Show user-friendly error messages with toast
- Log errors for debugging
- Implement error boundaries for components

```typescript
try {
  await createGame(gameData);
  toast.success('Game created successfully!');
} catch (error) {
  console.error('Failed to create game:', error);
  toast.error('Failed to create game. Please try again.');
}
```

## Testing Strategy
- Currently no automated tests
- Manual testing checklist in USER_TESTING_CHECKLIST.md
- Future: Add Vitest + React Testing Library

## Performance Best Practices
- Use React Query caching
- Implement pagination for lists
- Lazy load heavy components
- Optimize images before upload
- Use virtual scrolling for long lists
- Debounce search inputs
- Memoize expensive computations

## Deployment
- Frontend: Vercel
- Backend: Supabase (hosted)
- Environment variables in Supabase secrets
- Production build optimizations in vite.config.ts

## Key Business Rules (Critical!)
1. **Games cannot be modified within 2 hours of start time**
2. **Weather thresholds vary by sport type**
3. **All games must have valid location coordinates**
4. **Users must complete onboarding before accessing app**
5. **Real-time updates required for active game views**

## When Making Changes
1. Consider impact on other domains
2. Update TypeScript interfaces
3. Handle loading and error states
4. Test on mobile viewport
5. Check real-time functionality
6. Verify RLS policies if touching database
7. Update relevant README if changing business logic

## Getting Help
- Check domain README files for specific contexts
- Review existing similar components for patterns
- Supabase docs for database operations
- Radix UI docs for component usage
